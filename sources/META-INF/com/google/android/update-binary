#!/sbin/sh

<<LICENSE
  Copyright (C) 2016-2017  ale5000
  This file is part of microG unofficial installer by @ale5000.

  microG unofficial installer is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version, w/microG unofficial installer zip exception.

  microG unofficial installer is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with microG unofficial installer.  If not, see <http://www.gnu.org/licenses/>.
LICENSE

### GLOBAL VARIABLES ###

export LIVE_SETUP=0
export DEBUG_LOG=0
export RECOVERY_API_VER="$1"
export RECOVERY_PIPE="/proc/self/fd/$2"
export ZIP_FILE="$3"
export ZIP_PATH=$(dirname "$ZIP_FILE")
BASE_TMP_PATH='/tmp'
TMP_PATH='/tmp/custom-setup-a5k'

MANUAL_TMP_MOUNT=0

GENER_ERROR=0
STATUS=1


### FUNCTIONS ###

enable_debug_log()
{
  exec 3>&1 4>&2  # Backup stdout and stderr
  exec 1>>"$ZIP_PATH/debug-a5k.log" 2>&1
}

disable_debug_log()
{
  exec 1>&3 2>&4  # Restore stdout and stderr
}

ui_msg()
{
  echo -e "ui_print $1\nui_print" >> $RECOVERY_PIPE
  if [ "$DEBUG_LOG" -ne 0 ]; then echo "$1"; fi
}

ui_debug()
{
  echo "$1"
}

ui_error()
{
  #>&2 echo "ERROR: $1"
  ui_msg "ERROR: $1"
  test -n "$2" && exit "$2"
  exit 79
}

is_mounted()
{
  case `mount` in
    *" $1 "*) return 0;;  # Mounted
  esac;
  return 1  # NOT mounted
}

getprop()
{
  test -e '/sbin/getprop' && /sbin/getprop "ro.${1}" || grep "^ro\.${1}=" '/default.prop' | head -n1 | cut -d '=' -f 2
}

is_substring()
{
  case "$2" in 
    *"$1"*) return 0;;  # Found
  esac;
  return 1  # NOT found
}

set_perm()
{
  local uid="$1"; local gid="$2"; local mod="$3"
  shift 3
  chown $uid.$gid "$@"; chown $uid:$gid "$@"
  chmod $mod "$@" || ui_error "chmod failed on '$@'" 81
}

set_perm_safe()
{
  local uid="$1"; local gid="$2"; local mod="$3"
  shift 3
  "$BASE_TMP_PATH/busybox" chown $uid:$gid "$@" || ui_error "chown failed on '$@'" 81
  "$BASE_TMP_PATH/busybox" chmod $mod "$@" || ui_error "chmod failed on '$@'" 81
}

package_extract_file()
{
  unzip -opq "$ZIP_FILE" "$1" > "$2" || ui_error "Failed to extract the file '$1' from this archive" 82
}

package_extract_file_safe()
{
  "$BASE_TMP_PATH/busybox" unzip -opq "$ZIP_FILE" "$1" > "$2" || ui_error "Failed to extract the file '$1' from this archive" 83
}

create_dir()
{
  mkdir -p "$1" || ui_error "Failed to create the dir '$dir'" 84
  set_perm 0 0 0755 "$1"
}

create_dir_safe()
{
  "$BASE_TMP_PATH/busybox" mkdir -p "$1" || ui_error "Failed to create the dir '$dir'" 84
  set_perm_safe 0 0 0755 "$1"
}

delete_safe()
{
  "$BASE_TMP_PATH/busybox" rm -f "$@" || ui_error "Failed to delete files" 85
}

delete_recursive_safe()
{
  "$BASE_TMP_PATH/busybox" rm -rf "$@" || ui_error "Failed to delete files/folders" 86
}

check_key()
{
  case "$1" in
  42)  # Vol +
    return 3;;
  21)  # Vol -
    return 2;;
  143)  # Nothing selected
    return 1;;
  *)
    return 0;;
  esac
}

choose_timeout()
{
  timeout -t "$1" "$BASE_TMP_PATH/keycheck"
  check_key "$?"
  return "$?"
}

choose()
{
  local result=1
  ui_msg "QUESTION: $1"
  ui_msg "$2"
  ui_msg "$3"
  while true; do
    timeout -t 1 "$BASE_TMP_PATH/keycheck"; result="$?"
    if [ "$result" -ne 143 ]; then check_key "$result"; return "$?"; fi
    sleep 0.03
  done
}


### CODE ###

test "$DEBUG_LOG" -ne 0 && enable_debug_log  # Enable file logging if needed

ui_debug 'PRELOADER'
if ! is_mounted '/tmp'; then
  # Workaround: create and mount /tmp if it isn't already mounted
  MANUAL_TMP_MOUNT=1
  ui_msg 'WARNING: Creating missing /tmp...'
  if [ ! -e '/tmp' ]; then create_dir '/tmp'; fi
  mount -v -t tmpfs -o rw tmpfs /tmp
  set_perm 0 2000 0775 '/tmp'

  if ! is_mounted '/tmp'; then ui_error '/tmp is NOT mounted'; fi
fi

ABI_LIST=','$(getprop 'product.cpu.abilist')','$(getprop 'product.cpu.abi')','$(getprop 'product.cpu.abi2')','

if is_substring ',x86,' "$ABI_LIST"; then
  ui_debug 'Extracting x86 BusyBox...'
  package_extract_file 'misc/busybox/busybox-x86' "$BASE_TMP_PATH/busybox"
elif is_substring ',armeabi,' "$ABI_LIST"; then
  ui_debug 'Extracting ARM BusyBox...'
  package_extract_file 'misc/busybox/busybox-arm' "$BASE_TMP_PATH/busybox"
  package_extract_file 'misc/keycheck/keycheck-arm' "$BASE_TMP_PATH/keycheck"
else
  ui_error 'Unsupported CPU'
fi
set_perm 0 0 0755 "$BASE_TMP_PATH/busybox"  # Give it execution rights
test -e "$BASE_TMP_PATH/keycheck" && set_perm_safe 0 0 0755 "$BASE_TMP_PATH/keycheck"  # Give it execution rights

# Delete previous traces
delete_recursive_safe "$TMP_PATH"
create_dir_safe "$TMP_PATH"

# Extract scripts
ui_debug 'Extracting scripts...'
create_dir_safe "$TMP_PATH/inc"
package_extract_file_safe 'inc/common.sh' "$TMP_PATH/inc/common.sh"
package_extract_file_safe 'uninstall.sh' "$TMP_PATH/uninstall.sh"
package_extract_file_safe 'install.sh' "$TMP_PATH/install.sh"
set_perm_safe 0 0 0755 "$TMP_PATH/inc/common.sh"  # Give it execution rights
set_perm_safe 0 0 0755 "$TMP_PATH/uninstall.sh"  # Give it execution rights
set_perm_safe 0 0 0755 "$TMP_PATH/install.sh"  # Give it execution rights

# Temporarily install BusyBox
create_dir_safe "$TMP_PATH/bin"
"$BASE_TMP_PATH/busybox" --install -s "$TMP_PATH/bin"
# Clean search path so only internal BusyBox applets will be used
export PATH="$TMP_PATH/bin"

# Live setup
ui_msg 'Select the volume + key to enable live setup.'
ui_msg 'Waiting input for 2 seconds...'
choose_timeout 2; test "$?" -eq 3 && export LIVE_SETUP=1

if [ "$LIVE_SETUP" -ne 0 ]; then
  ui_msg 'LIVE SETUP ENABLED!'
  if [ "$DEBUG_LOG" -eq 0 ]; then
    choose 'Do you want to enable the debug log?' '+) Yes' '-) No'; if [ "$?" -eq 3 ]; then export DEBUG_LOG=1; enable_debug_log; fi
  fi
fi

ui_debug 'Starting installation script...'
"$BASE_TMP_PATH/busybox" bash -c "'$TMP_PATH/install.sh' Preloader '$TMP_PATH'"; STATUS="$?"

test -f "$TMP_PATH/installed" || GENER_ERROR=1
delete_recursive_safe "$TMP_PATH"

test "$DEBUG_LOG" -ne 0 && disable_debug_log  # Restore status

test "$MANUAL_TMP_MOUNT" -ne 0 && (umount '/tmp' || ui_error 'Cannot unmount /tmp')

if test "$STATUS" -ne 0; then ui_error "Installation script failed with error $STATUS" "$STATUS"; fi
if test "$GENER_ERROR" -ne 0; then ui_error 'Installation failed with an unknown error'; fi

delete_safe "$BASE_TMP_PATH/keycheck"
delete_safe "$BASE_TMP_PATH/busybox"
